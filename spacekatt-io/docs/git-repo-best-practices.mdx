---
id: git-repo-best-practices
title: "Best Practices for Setting Up Git Repositories: A Comprehensive Guide"
sidebar_label: Git Repo Setup Best Practices
---

So, you're creating a new project and need to set up a fresh `git` repository...

Open source projects have a standard set of components engineers expect to see in a repo.

Inclusion of all standard components is a positive signal of the repo maintainer's experience and professionalism.

Exclusion of any of these standard components may provoke a negative bias from the reader.
Engineers often immediately navigate away from projects without these components, as they are signals of a project's health and reliability.

This guide will teach you how to:

- Set up a new, local repository
- Include standard components industry engineers expect to see
- Curate an open, collaborative environment (with proper guard rails)
- Consider continuous integration, release strategies, testing, linting, and more!

Let us begin.

:::tip
For this guide I will be using env vars to ease copy paste.
Please `export` the name of your repository to take advantage of this:

```bash
export MY_AWESOME_REPO=<repo-name> && echo $MY_AWESOME_REPO
```

I am also assuming you are using a bash-like shell and have `$USER` as a prexisting env var.
:::

## Initializing a New Local Repo

> *"A library with a thousand downloads begins with a single commit."* - ***idk, probably Torvalds***

Repositories are essentially directories where every change made is tracked and stored for posterity.

**Every** project should [use source control](https://betterprogramming.pub/9-reasons-even-solo-developers-should-use-source-control-c4f5939e2a36).
Without source control, chaos reigns.

`git` is *the* industry favorite tool for source control.
Other tools exist (e.g., Fossil, SVN, CVS, Mercurial, etc...), however they are rare to see out in the wild.

Run the following commands to create a new directory, navigate to it, and create an empty `git` repo:

```bash
mkdir $MY_AWESOME_REPO
cd $MY_AWESOME_REPO
git init
```

Congradulations! You now have an empty `git` repo ready to use for source control excellence!

:::note
Configuration and tracking of `git` history is stored in the `.git/` directory, which has the following structure:

```
.
└── .git
    ├── HEAD
    ├── config
    ├── description
    ├── hooks
    ├── info
    ├── objects
    └── refs
```
:::

If you have not already, please configure your [name and email](https://stackoverflow.com/a/37805844/4656516), as `git` requires it.

Herein, we assume the reader knows basic git operations, such as
[`add`](https://www.atlassian.com/git/tutorials/saving-changes),
[`commit`](https://www.atlassian.com/git/tutorials/saving-changes/git-commit),
and [`diff`](https://www.atlassian.com/git/tutorials/saving-changes/git-diff).

This guide is **not** a [git tutorial](https://git-scm.com/docs/gittutorial),
rather it is a compilation of best practices and steps settin up new repos.

:::note
Industry is shifting towards a preference for naming the default [`git` branch to `main`](https://github.com/github/renaming/#readme).
To change your current branch's name from `master` to `main` and set the default branch name made by future `$ git init` invocations, run the following:

```bash
git branch -m main
git config --global init.defaultBranch main
```
:::

## Add a `LICENSE`

> *"Lawsuits are never a fashionable thing to wear."* - **someone who always uses a `LICENSE`**

Software licensing is too often considered a second priority to functionality and overlooked by new coders.

However, one never knows how their code will be used - possibly years later - once it is in the public domain.
Protection from liability is an essential facet of open source software and trivial to implement.

All you need to do is:

- Copy the following [MIT License](https://choosealicense.com/licenses/mit/)
- Paste it in a `LICENSE.md` file
- Set the `[year] [fullname]` fields
- Never worry about it again! (Maybe you'll update the `[year]` occasionally)

```txt title="LICENSE.md"
MIT License

Copyright (c) [year] [fullname]

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
```

:::info
I prefer a `MIT License` for a variety of reasons, however there are a multitude of licenses - some of which may be more appropriate for your project!
For instance, the "viral" [`GNU GPLv3 License`](https://choosealicense.com/licenses/) is useful if you want  any project taking a dependecy on yours to use the same license.

Please take some time to familiarize yourself with the [common set of licenses](https://choosealicense.com/licenses/) used by open source projects.
:::

## Add a `README`

> *"Where's your `README`?"* - **a frusturated engineer**

Projects without a `README` files are persona non grata in the open soure world.

Trust is the coin of the realm, and engineers do not trust projects without a `README`!

Repo hosting websites (such as GitHub) believe in the `README` file to such a degree where they [automatically render `README`s](https://docs.github.com/en/repositories/managing-your-repositorys-settings-and-features/customizing-your-repository/about-readmes) in every repo.
Everyone expects you to have one; `README`s are built into the basic muscle memory of the organs of industry.

One of the first few commits in a new repository should create a new `README.md` file.
I typically use the following basic template:

```md title="README.md"
# <REPO_NAME>

<BRIEF_DESCRIPTION_OF_INTENT>
```

Simple scaffolding - such as the template above - is sufficient until you have built out more functionality in your project.

As your project grows, folk should be able to understand what your project is about and how to get started using it by reading the `README`.
If a reader needs to dig around in other files to understand the basics of how to use your project, then those files should be linked to in the `README`.

In a world of growing complexity, the simplest thing you can do to make your project more accessible is having a banger `README`.

## Add a `.gitignore` File

- Add `.gitignore`

## Add a `CONTRIBUTING` Guide

- Add `CONTRIBUTING.md`
- Consider making a code of conduct

## Create Remote Repo (GitHub)

> *"git != GitHub"* - **every git workshop ever**

- Create GitHub repo online
- Set `origin` and `push`
  - `$ git remote add origin git@github.com:<username>/<my-awesome-repo>.git`
  - `$ git push origin main`

## Branch Protection Rules

Why have branch protection rules?

### Importance of Pull Requests

Pull requests allow for spliting...

[Pull request merging](https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/incorporating-changes-from-a-pull-request/merging-a-pull-request#merging-a-pull-request)

### Setting up Branch Rules

- set rules on `main`

### Merge Stategies

Decide on your merging strategy.

:::note
When working alone, I prefer to rebase branches locally then use GitHub's [`Rebase and merge`](https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/incorporating-changes-from-a-pull-request/about-pull-request-merges#rebase-and-merge-your-commits).
Use of `Rebase and merge` maintains a linear git history and

When working in an enterprise setting, I prefer to rebase branches locally then use GitHub's [`Squash and merge`](https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/incorporating-changes-from-a-pull-request/about-pull-request-merges#rebase-and-merge-your-commits).
Squash commits are nice to reduce the commit log noise (i.e., `main` will have thousands of commits instead of tens of thousands of commits).

The curious may consult futher reading on [linear history](https://dev.to/bladesensei/avoid-messy-git-history-3g26).
:::

## Scaffold Continuous Integration (CI)

- Add minimal CI
- add CI badge

## Decide on a Release Strategy (CD)

- I like `release/*` CD
- use `spacekatt-io` CD as example

### Libraries vs Applications

TODO: contrast publishing from deployment

## Language Specific Components

Certain standard components are language specific and beyond the scope of this guide.

### Linting

Linting should occur in CI and gate deployment.

### Testing

Testing should occur in CI and gate deployment.

## Further Considerations

### Documentation

Docs

### Onboarding Guides

Onboarding

### Engineering Fundamentals

Please consider engineering fundamentals such as security, observability, and documentation.

- [Engineering Fundamentals Checklist](https://microsoft.github.io/code-with-engineering-playbook/ENG-FUNDAMENTALS-CHECKLIST/)
